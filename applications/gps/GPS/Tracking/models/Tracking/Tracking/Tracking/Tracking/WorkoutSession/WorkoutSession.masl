//! ACTIVITY BEGIN. 'e3f7be53-3ad2-47d3-862a-9a65846facde' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.addHeartRateSample ( heartRate : in integer ) is
workoutTimer: instance of WorkoutTimer;
sample: instance of HeartRateSample;
display: instance of Display;
begin
  // Add a new heart-rate sample and notify the UI of the current heart rate.
  
  workoutTimer := this->R8.is_timed_by.WorkoutTimer;
  
  // Create and initialize a new heart-rate sample.
  sample := create HeartRateSample( session_startTime => this.startTime, time => workoutTimer.time );
  sample.heartRate := heartRate;
  link this R6.tracks_heart_rate_over_time_as sample;
  
  // Notify UI of the new heart rate.
  display := this->R7.current_status_indicated_on.Display;
  generate Display.refresh() to display;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0a3c180b-9d9a-457a-ab39-2114964b5908' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.clearHeartRateSamples () is
samples: set of instance of HeartRateSample;
begin
  samples := this->R6.HeartRateSample;
  for sample in samples loop
    unlink this R6 sample;
    delete sample;
  end loop;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '3c3e9447-7fbe-40c3-835d-aa668b911afa' DO NOT EDIT THIS LINE.
public service Tracking::WorkoutSession.initialize () is
session: instance of WorkoutSession;
workoutTimer: instance of WorkoutTimer;
trackLog: instance of TrackLog;
display: instance of Display;
begin
  // Unless a workout session already exists, create and initialize a 
  // workout session, workout timer, and tracklog, and relate them all.
  
  session := find_one WorkoutSession();
  
  if ( null = session ) then
  
    // Create a workout session.
    //session := create WorkoutSession( startTime => timestamp'now() );
    session := create WorkoutSession( startTime => @2022-03-21T00:00:00Z@ );
    // Initialize this workout session.
    session.accumulatedDistance := 0.0;
  
    // Create a workout timer.
    workoutTimer := create WorkoutTimer(  session_startTime => session.startTime, Current_State => stopped );
    workoutTimer.initialize();
  
    // Create a track log.
    trackLog := create TrackLog(  session_startTime => session.startTime );
    
    // Create a display.
    display := create Display( session_startTime => session.startTime, Current_State => displayDistance );
  
    // Relate them all together.
    link trackLog R4.represents_path_for session;
    link workoutTimer R8.acts_as_the_stopwatch_for session;
    link display R7.indicates_current_status_of session;
    
  end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a20ddab3-779d-44fd-bea2-d5477b04a7b3' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.reset () is
workoutTimer: instance of WorkoutTimer;
trackLog: instance of TrackLog;
goalSpecs: set of instance of GoalSpec;
executingGoal: instance of Goal;
openAchievement: instance of Achievement;
goals: set of instance of Goal;
achievements: set of instance of Achievement;
begin
  // Reset this session, including the timer, track log, goal specifications,
  // goals, and achievement records.
  
  // Reset the timer.
  workoutTimer := this->R8.is_timed_by.WorkoutTimer;
  workoutTimer.initialize();
  
  // Reset the track log.
  trackLog := this->R4.captures_path_in.TrackLog;
  trackLog.clearTrackPoints();
  trackLog.clearLapMarkers();
  
  // Remove all goal specifications.
  goalSpecs := this->R10.includes.GoalSpec;
  for goalSpec in goalSpecs loop
    unlink this R10.includes goalSpec;
    delete goalSpec;
  end loop;
  
  // Remove any currently executing goal and open achievement record.
  executingGoal := this->R11.is_currently_executing.Goal;
  if ( null /= executingGoal ) then
    openAchievement := executingGoal->R14.has_open.Achievement;
    if ( null /= openAchievement ) then
      unlink openAchievement R14.is_open_for executingGoal;
      delete openAchievement;
    end if;
    unlink this R11.is_currently_executing executingGoal;
    delete executingGoal;
  end if;
  
  // Remove all other goals and achievement records.
  goals := this->R13.has_executed.Goal;
  for goal in goals loop
    achievements := goal->R12.has_recorded.Achievement;
    for achievement in achievements loop
      unlink goal R12.has_recorded achievement;
      delete achievement;
    end loop;
    unlink this R13.has_executed goal;
    delete goal;
  end loop;
  
  // Reset the session.
  this.accumulatedDistance := 0.0;
  this.clearHeartRateSamples();
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e96224fd-c698-497e-b876-5d78df9890a3' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.getCurrentSpeed () return real is
lastPoint: instance of TrackPoint;
speed: real;
cursor: instance of TrackPoint;
spd: instance of Speed;
index: integer;
totalDistance: real;
elapsedTime: real;
previousPoint: instance of TrackPoint;
distance: real;
begin
  // Calculate the current speed, expressed in km per hour, by summing 
  // the straight-line distance between each of several of the most recent 
  // track points and then dividing that sum by the elapsed time between 
  // the first and last point in the subset used for the calculation.
  
  lastPoint := this->R4.captures_path_in.TrackLog->R3.has_last.TrackPoint;
  speed := 0.0;
  if ( null /= lastPoint ) then
    cursor := lastPoint;
    Speed.initialize();
    spd := find_one Speed();
    index := spd.SpeedAveragingWindow;  // Number of track points to use when calculating average speed.
    totalDistance := 0.0;
    elapsedTime := real(lastPoint.time);
    while ( index > 0 ) loop
      previousPoint := cursor->R2.preceeds.TrackPoint;
      if ( null = previousPoint ) then
        exit;
      end if;
      LOC~>getDistance( distance, cursor.latitude, cursor.longitude, previousPoint.latitude, previousPoint.longitude );
      totalDistance := totalDistance + distance;
      index := index - 1;
      cursor := previousPoint;
    end loop;
    elapsedTime := elapsedTime - real(cursor.time);
    speed := (totalDistance / 1000) / (elapsedTime / spd.SecondsPerHour);
  end if;
  
  return speed;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '8a49c77a-61a5-4d4e-b83c-04ba076f93ea' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.getCurrentPace () return real is
result: real;
begin
  // Calculate current pace from current speed, converting from km/hour to minutes/km.
  result := 0.0;
  if ( this.getCurrentSpeed() /= 0.0 ) then
    result := 60.0 / this.getCurrentSpeed();
  else
    result := 0.0;
  end if;
  
  return result;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd88b756e-d419-4489-921e-2296c1f113b6' DO NOT EDIT THIS LINE.
public instance service Tracking::WorkoutSession.getCurrentHeartRate () return integer is
hrc: instance of HeartRateConstants;
workoutTimer: instance of WorkoutTimer;
samples: set of instance of HeartRateSample;
sample: instance of HeartRateSample;
numberOfSamples: integer;
sum: integer;
result: integer;
begin
  // Calculate sliding average using the most recent samples.
  HeartRateConstants.initialize();
  hrc := find_one HeartRateConstants();
  workoutTimer := this->R8.is_timed_by.WorkoutTimer;
  samples := find (this->R6.tracks_heart_rate_over_time_as.HeartRateSample)( time >= ( workoutTimer.time - (hrc.HeartRateSamplingPeriod * hrc.HeartRateAveragingWindow) ) );
  numberOfSamples := 0;
  sum := 0;
  result := 0;
  for sample in samples loop
    numberOfSamples := numberOfSamples + 1;
    sum := sum + sample.heartRate;
  end loop;
  if ( numberOfSamples > 0 ) then
    result := sum / numberOfSamples;
  end if;
  
  return result;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

